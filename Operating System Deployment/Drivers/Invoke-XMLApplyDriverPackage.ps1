<#
.SYNOPSIS
	Download driver package matching computer model, manufacturer and operating system.
	
.DESCRIPTION
    This script will determine the model of the computer, manufacturer and matching variables required to use Modern Driver Management
	in conjunction with a model XML list generated by the Driver Automation Tool. 

.PARAMETER DeploymentType
	Define a different deployment scenario other than the default behavior. Choose between BareMetal (default), OSUpgrade or DriverUpdate.	
	
.PARAMETER DriverInstallMode
	Specify whether to install drivers using DISM.exe with recurse option or spawn a new process for each driver.

.PARAMETER StoragePath
	Specify a UNC or local path available at runtime to query for available drivers

.PARAMETER OS
	Specify the operating system being deployed. By default Windows 10 is selected

.PARAMETER Architecture
	Specify the operating system architecture being deployed. By default 64-bit (x64) is selected.

.PARAMETER OSVersion
	Applicable to Windows 10 deployments for matching against version specific driver packages. By default 1809 is selected.

.PARAMETER CleanUp
	By default the temporary driver folder that is used to copy content down to the local disk is removed after the drivers are applied.
	Specifying a $false value will prevent the folder from being removed.

.PARAMETER DebugMode
	Use this switch when running script outside of a Task Sequence.

.EXAMPLE
	# Detect, download and apply drivers during OS deployment using specified storage location and OS details:
	.\Invoke-CMApplyDriverPackage.ps1 -ModelXL -DeploymentType BareMetal -DriverInstallMode Recurse -StoragePath '\\SERVER\DriverDownloads' -OS 'Windows 10' -OSArchitecture x64

	
.NOTES
    FileName:    Invoke-XMLApplyDriverPackage.ps1
    Author:      Nickolaj Andersen / Maurice Daly
    Contact:     @NickolajA / @MoDaly_IT
    Created:     2018-08-23
    Updated:     2019-03-11
    
    Version history:
	1.0.0 - (2018-08-28) Script created
  1.0.1 - (2019-03-11) merlinfrombelgium@gmail.com
    + Modifications to support 1809
    + $MatchingPackage: -match "$($OS.Replace(' ', ''))-$osversion-$Architecture"

#>
[CmdletBinding(SupportsShouldProcess = $true, DefaultParameterSetName = "Execute")]
param (
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Define a different deployment scenario other than the default behavior. Choose between BareMetal (default), OSUpgrade or DriverUpdate.")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateSet("BareMetal", "OSUpgrade", "DriverUpdate")]
	[string]$DeploymentType = "BareMetal",
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Specify if the script is to be used with a driver fallback package.")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[switch]$UseDriverFallback,
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Specify whether to install drivers using DISM.exe with recurse option or spawn a new process for each driver.")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateNotNullOrEmpty()]
	[ValidateSet("Single", "Recurse")]
	[string]$DriverInstallMode = "Recurse",
	
	[parameter(Mandatory = $true, ParameterSetName = "Execute", HelpMessage = "Specify the storage path used for local storage XML based matching.")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateNotNullOrEmpty()]
	[string]$StoragePath,
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Specify the version of Windows being deployed")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateSet("Windows 7", "Windows 8", "Windows 8.1", "Windows 10")]
	[string]$OS = "Windows 10",
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Specify the architecture of the Windows image being deployed")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateSet("x86", "x64")]
	[string]$Architecture = "x64",
	
	[parameter(Mandatory = $false, ParameterSetName = "Execute", HelpMessage = "Specify the Windows 10 build number")]
	[parameter(Mandatory = $false, ParameterSetName = "Debug")]
	[ValidateSet("1607", "1703", "1709", "1803", "1809")]
	[string]$OSVersion = "1809",
	
	[parameter(Mandatory = $false, HelpMessage = "Use this switch to remove the driver package post application")]
	[boolean]$CleanUp = $true,
	
	[parameter(Mandatory = $true, ParameterSetName = "Debug", HelpMessage = "Use this switch when running script outside of a Task Sequence.")]
	[switch]$DebugMode
)
Begin {
	if ($PSCmdLet.ParameterSetName -match "Execute") {
		# Load Microsoft.SMS.TSEnvironment COM object
		try {
			$TSEnvironment = New-Object -ComObject Microsoft.SMS.TSEnvironment -ErrorAction Continue
			$TSEnvironmentRunning = $true
		}
		catch [System.Exception] {
			Write-Warning -Message "Unable to construct Microsoft.SMS.TSEnvironment object"
		}
	}
	[version]$ScriptVersion = "1.0.1"
}
Process {
	# Set Log Path
	switch ($DeploymentType) {
		"OSUpgrade" {
			$LogsDirectory = Join-Path -Path $env:SystemRoot -ChildPath "Temp"
		}
		"DriverUpdate" {
			$LogsDirectory = Join-Path -Path $env:SystemRoot -ChildPath "Temp"
		}
		Default {
			if ($TSEnvironment -match $null) {
				$LogsDirectory = Join-Path $env:SystemRoot "Temp"
			}
			else {
				$LogsDirectory = $Script:TSEnvironment.Value("_SMSTSLogPath")
			}
		}
	}
	
	# Functions
	function Write-CMLogEntry {
		param (
			[parameter(Mandatory = $true, HelpMessage = "Value added to the log file.")]
			[ValidateNotNullOrEmpty()]
			[string]$Value,
			[parameter(Mandatory = $true, HelpMessage = "Severity for the log entry. 1 for Informational, 2 for Warning and 3 for Error.")]
			[ValidateNotNullOrEmpty()]
			[ValidateSet("1", "2", "3")]
			[string]$Severity,
			[parameter(Mandatory = $false, HelpMessage = "Name of the log file that the entry will written to.")]
			[ValidateNotNullOrEmpty()]
			[string]$FileName = "ApplyDriverPackage.log"
		)
		# Determine log file location
		$LogFilePath = Join-Path -Path $LogsDirectory -ChildPath $FileName
		
		# Construct time stamp for log entry
		$Time = -join @((Get-Date -Format "HH:mm:ss.fff"), "+", (Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias))
		
		# Construct date for log entry
		$Date = (Get-Date -Format "MM-dd-yyyy")
		
		# Construct context for log entry
		$Context = $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)
		
		# Construct final log entry
		$LogText = "<![LOG[$($Value)]LOG]!><time=""$($Time)"" date=""$($Date)"" component=""ApplyDriverPackage"" context=""$($Context)"" type=""$($Severity)"" thread=""$($PID)"" file="""">"
		
		# Add value to log file
		try {
			Out-File -InputObject $LogText -Append -NoClobber -Encoding Default -FilePath $LogFilePath -ErrorAction Stop
		}
		catch [System.Exception] {
			Write-Warning -Message "Unable to append log entry to ApplyDriverPackage.log file. Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)"
		}
	}
	
	# Windows Version Hash Table
	$WindowsBuildHashTable = @{`
		1809 = "10.0.17763.0"
		1803 = "10.0.17134.1"
		1709 = "10.0.16299.15";`
		1703 = "10.0.15063.0";`
		1607 = "10.0.14393.0";`
	};
	
	function Invoke-Executable {
		param (
			[parameter(Mandatory = $true, HelpMessage = "Specify the file name or path of the executable to be invoked, including the extension")]
			[ValidateNotNullOrEmpty()]
			[string]$FilePath,
			[parameter(Mandatory = $false, HelpMessage = "Specify arguments that will be passed to the executable")]
			[ValidateNotNull()]
			[string]$Arguments
		)
		
		# Construct a hash-table for default parameter splatting
		$SplatArgs = @{
			FilePath	    = $FilePath
			NoNewWindow	    = $true
			Passthru	    = $true
			ErrorAction	    = "Stop"
		}
		
		# Add ArgumentList param if present
		if (!([System.String]::IsNullOrEmpty($Arguments))) {
			$SplatArgs.Add("ArgumentList", $Arguments)
		}
		
		# Invoke executable and wait for process to exit
		try {
			$Invocation = Start-Process @SplatArgs
			$Handle = $Invocation.Handle
			$Invocation.WaitForExit()
		}
		catch [System.Exception] {
			Write-Warning -Message $_.Exception.Message; break
		}
		
		return $Invocation.ExitCode
	}
		
	# Write log file for script execution
	Write-CMLogEntry -Value "===== SCConfigMgr Invoke-XMLApplyDriverPackage Version $($ScriptVersion.ToString()) ====" -Severity 1
	if ($PSCmdLet.ParameterSetName -match "Execute") {
		Write-CMLogEntry -Value "Driver download package process initiated" -Severity 1
	}
	elseif ($PSCmdLet.ParameterSetName -eq "Debug") {
		Write-CMLogEntry -Value "Driver download package process initiated in debug mode" -Severity 1
	}
	else {
		Write-CMLogEntry -Value "Driver download package process initiated using model XML based search" -Severity 1
	}
	
	# Determine manufacturer
	$ComputerManufacturer = (Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Manufacturer).Trim()
	
	# Determine manufacturer name and hardware information
	switch -Wildcard ($ComputerManufacturer) {
		"*Microsoft*" {
			$ComputerManufacturer = "Microsoft"
			$ComputerModel = (Get-WmiObject -Namespace root\wmi -Class MS_SystemInformation | Select-Object -ExpandProperty SystemSKU).Replace("_", " ")
		}
		"*HP*" {
			$ComputerManufacturer = "Hewlett-Packard"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model
			$SystemSKU = (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).BaseBoardProduct
		}
		"*Hewlett-Packard*" {
			$ComputerManufacturer = "Hewlett-Packard"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model
			$SystemSKU = (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).BaseBoardProduct
		}
		"*Dell*" {
			$ComputerManufacturer = "Dell"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model
			$SystemSKU = (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).SystemSku
		}
		"*Lenovo*" {
			$ComputerManufacturer = "Lenovo"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystemProduct | Select-Object -ExpandProperty Version
			$SystemSKU = ((Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model).SubString(0, 4)).Trim()
		}
		"*Panasonic*" {
			$ComputerManufacturer = "Panasonic Corporation"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model
			$SystemSKU = (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).BaseBoardProduct
		}
		"*Viglen*" {
			$ComputerManufacturer = "Viglen"
			$ComputerModel = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model
			$SystemSKU = Get-WmiObject -Class Win32_BaseBoard | Select-Object -ExpandProperty SKU
		}
	}
	
	# Fall back SystemSKU details	
	switch ($ComputerManufacturer) {
		"Dell" {
			$OEMString = Get-WmiObject -Class Win32_ComputerSystem | Select -ExpandProperty OEMStringArray
			$FallBackSKU = [regex]::Matches($OEMString, '\[\S*]')[0].Value.TrimStart("[").TrimEnd("]")
		}
	}
	
	# Output model info
	Write-CMLogEntry -Value "Manufacturer determined as: $($ComputerManufacturer)" -Severity 1
	Write-CMLogEntry -Value "Computer model determined as: $($ComputerModel)" -Severity 1
	if (!([string]::IsNullOrEmpty($SystemSKU))) {
		Write-CMLogEntry -Value "Computer SKU determined as: $($SystemSKU)" -Severity 1
	}
	else {
		Write-CMLogEntry -Value "Unable to determine system SKU value" -Severity 2
	}
	if (!([string]::IsNullOrEmpty($FallBackSKU))) {
		Write-CMLogEntry -Value "Fallback SKU determined as: $($FallBackSKU)" -Severity 1
	}
	
	# Output OS information
	Write-CMLogEntry -Value "Operating system selected - $($OS)" -Severity 1
	Write-CMLogEntry -Value "Operating system architecture - $($Architecture)" -Severity 1
	if ($OS -match "10") {
		Write-CMLogEntry -Value "Operating system version - $($OSVersion)" -Severity 1
	}
	
	# Construct array list for matching packages
	$PackageList = New-Object -TypeName System.Collections.ArrayList
	
	# Set script error preference variable
	$ErrorActionPreference = "Stop"

	# Set OS Image Version Number
	if (([string]::IsNullOrEmpty($OSVersion)) -and ($ComputerManufacturer -notmatch "Dell") -and ($OS -match "Windows 10")) {
		$OSVersion = $($WindowsBuildHashTable.Keys.Where({
					$WindowsBuildHashTable[$_] -match $OSImageVersion
				}))
	}
	# Get list of available packages
	if (Test-Path -Path $StoragePath) {
		Write-CMLogEntry -Value "Reading models xml file from $(Join-Path -Path $StoragePath -ChildPath 'ModelDetails.xml')" -Severity 1
		[xml]$PackageDetails = Get-Content -Path (Join-Path -Path $StoragePath -ChildPath "ModelDetails.xml")
		$Packages = $PackageDetails.Details.ModelDetails | Where-Object {
			$_.Make -match $ComputerManufacturer
		}
		Write-CMLogEntry -Value "Retrieved a total of $(($Packages.Model).Count) $($ComputerManufacturer) driver packages from storage repository" -Severity 1
	}
	else {
		$Packages = $null
	}
	
	# Validate operating system name was detected
	if ($OS -ne $null) {
		# Validate not virtual machine
		$ComputerSystemType = Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty "Model"
		
		if ($ComputerSystemType -notin @("Virtual Machine", "VMware Virtual Platform", "VirtualBox", "HVM domU", "KVM")) {
			if ($Packages -ne $null) {
				if (($ComputerModel -ne $null) -and (!([System.String]::IsNullOrEmpty($ComputerModel))) -or (($SystemSKU -ne $null) -and (!([System.String]::IsNullOrEmpty($SystemSKU))))) {
					# Determine computer model detection
					if ([System.String]::IsNullOrEmpty($SystemSKU)) {
						$ComputerDetectionMethod = "ComputerModel"
					}
					else {
						$ComputerDetectionMethod = "SystemSKU"
					}
					Write-CMLogEntry -Value "Using computer detection method: $($ComputerDetectionMethod)" -Severity 1
					
					# Process each package returned from web service
					foreach ($Package in $Packages) {
						Write-CMLogEntry -Value "Attempting to find a match for driver package: $($Package.Make) $($Package.Model)" -Severity 1
						$DetectionContinue = $true
						
						If ($DetectionContinue -eq $true) {
							$ComputerDetectionResult = $false
							$PackageNameComputerModel = $Package.Model
							$ComputerDetectionResult = $true
							# Computer detection method matching
							switch ($ComputerDetectionMethod) {
								"ComputerModel" {
									if ($PackageNameComputerModel -match $ComputerModel) {
										Write-CMLogEntry -Value "Match found for computer model using detection method: $($ComputerDetectionMethod) ($($ComputerModel))" -Severity 1
										$ComputerDetectionResult = $true
									}
								}
								"SystemSKU" {
									# Handle vendor specific delimiters
									switch ($ComputerManufacturer) {
										"Hewlett-Packard" {
											if ($SystemSKU -match ",") {
												$SystemSKUDelimiter = ","
											}
										}
										"Dell" {
											if ($SystemSKU -match ";") {
												$SystemSKUDelimiter = ";"
											}
										}
									}
									if (-not ([string]::IsNullOrEmpty($SystemSKUDelimiter))) {
										Write-CMLogEntry -Value "Multiple SKU values detected. Attempting to match for each value" -Severity 1
										foreach ($SKU in $($SystemSKU -split $SystemSKUDelimiter)) {
											Write-CMLogEntry -Value "Attempting to match for SKU value: $($SKU)" -Severity 1
											if ($Package.SystemSKU -match $SKU) {
												$SKUMatchDetectionResult = $true
											}
											else {
												$SKUMatchDetectionResult = $false
											}
										}
										if ($SKUMatchDetectionResult -eq $true) {
											Write-CMLogEntry -Value "Match found for computer model using detection method: $($ComputerDetectionMethod) ($($SystemSKU))" -Severity 1
											$ComputerDetectionResult = $true
										}
									}
									elseif ($Package.SystemSKU -match $SystemSKU) {
										Write-CMLogEntry -Value "Match found for computer model using detection method: $($ComputerDetectionMethod) ($($SystemSKU))" -Severity 1
										$ComputerDetectionResult = $true
									}
									elseif (!([string]::IsNullOrEmpty($FallBackSKU))) {
										
										if ($FallBackSKU -match ";") {
											Write-CMLogEntry -Value "Multiple SKU values detected. Attempting to match for each value" -Severity 1
											foreach ($SKU in $($FallBackSKU -split ";")) {
												if ($Package.SystemSKU -match $SKU) {
													$SystemSKU = $FallBackSKU
													$SKUMatchDetectionResult = $true
												}
											}
											if ($SKUMatchDetectionResult -eq $true) {
												Write-CMLogEntry -Value "Match found for computer model using detection method: Fallback SKU" -Severity 1
												$ComputerDetectionResult = $true
											}
										}
										elseif ($Package.SystemSKU -match $FallBackSKU) {
											Write-CMLogEntry -Value "Match found for computer model using detection method: Fallback SKU" -Severity 1
											$ComputerDetectionResult = $true
										}
									}
									
									if ($ComputerDetectionResult -ne $true) {
										Write-CMLogEntry -Value "Unable to match computer model using detection method: $($ComputerDetectionMethod) ($($SystemSKU))" -Severity 2
										if ($PackageNameComputerModel -match $ComputerModel) {
											Write-CMLogEntry -Value "Fallback from SystemSKU match found for computer model instead using detection method: $($ComputerDetectionMethod) ($($ComputerModel))" -Severity 1
											$ComputerDetectionResult = $true
										}
										$ComputerDetectionResult = $true
									}
								}
							}
							
							# Match manufacturer, operating system name and architecture criteria
							if ($ComputerDetectionResult -eq $true) {
								if (($SystemSKU -match $Package.SystemSKU) -and ($ComputerManufacturer -match $Package.Make)) {
									# Set package path based on vendor and OS details
									switch -wildcard ($Package.Make) {
										"*Dell*" {
											$MatchingPackage = Get-ChildItem -Recurse -Path (Join-Path -Path $StoragePath -ChildPath "$($Package.Make)\$($Package.Model)") -Depth 2 | Where-Object {
												$_.Name -match $($OS.Replace(" ", ""))
											} | Sort-Object LastWriteTime -Descending | select -First 1
										}
										default {
											$MatchingPackage = Get-ChildItem -Recurse -Path (Join-Path -Path $StoragePath -ChildPath "$($Package.Make)\$($Package.Model)") -Depth 2 | Where-Object {
												$_.Name -match "$($OS.Replace(' ', ''))-$OSVersion-$Architecture"
											} | Sort-Object LastWriteTime -Descending | select -First 1
										}
									}
									
									Write-CMLogEntry -Value "Validating driver package path $($MatchingPackage)" -Severity 1
									if (!([string]::IsNullOrEmpty($MatchingPackage.FullName))) {
										Write-CMLogEntry -Value "Driver package found at $($MatchingPackage.FullName)" -Severity 1
										$PackageList.Add($MatchingPackage.FullName) | Out-Null
										$MatchFound = $true
									}
									else {
										Write-CMLogEntry -Value "Driver package could not be found in referenced storage location - $(Join-Path -Path $StoragePath -ChildPath "$($Package.Make)\$($Package.Model)") " -Severity 2
									}
								}
								else {
									Write-CMLogEntry -Value "Driver package does not meet computer model, manufacturer and operating system and architecture criteria: $($Package.PackageName) ($($Package.PackageID))" -Severity 2
								}
							}
							else {
								Write-CMLogEntry -Value "Driver package does not meet computer model criteria: $($Package.PackageName) ($($Package.PackageID))" -Severity 2
							}
						}
					}
					
					# Set OS drive location
					if ($TSEnvironmentRunning -eq $true) {
						$WindowsImageLocation = $($TSEnvironment.Value('OSDTargetSystemDrive'))
						if ([string]::IsNullOrEmpty($WindowsImageLocation)) {
							$WindowsImageLocation = $($TSEnvironment.Value('OSDisk'))
						}
					}
					
					# Fall back to Default C:\
					if ([string]::IsNullOrEmpty($WindowsImageLocation)) {
						$WindowsImageLocation = "C:\"
					}
					
					# Set local driver folder location
					$OSDDriverPackageLocation = Join-Path -Path $WindowsImageLocation -ChildPath "DriverFiles"
					
					Write-CMLogEntry -Value "Windows image location set to: $($WindowsImageLocation)" -Severity 1
					
					# Process matching items in package list
					if ($PackageList -ne $null) {
						# Determine the most current package from list
						if (!($PSCmdLet.ParameterSetName -eq "Debug")) {
							if ($PackageList.Count -eq 1) {
								try {
									# Attempt to download driver package content
									Write-CMLogEntry -Value "Driver package list contains a single match, attempting to download driver package content - $($PackageList[0])" -Severity 1
									try {
										# Create temporary driver storage path
										if (!(Test-Path -Path $OSDDriverPackageLocation)) {
											Write-CMLogEntry -Value "Creating local driver storage - $OSDDriverPackageLocation" -Severity 1
											New-Item -Type Dir -Path $OSDDriverPackageLocation | Out-Null
										}
										Copy-Item -Path "$($PackageList[0])" -Recurse -Destination $OSDDriverPackageLocation -Force
										$DownloadInvocation = 0
									}
									catch [System.Exception] {
										Write-CMLogEntry -Value "An error occurred while copying driver package content. Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 1
									}
									
									try {
										if ($DownloadInvocation -eq 0) {
											if ($PSCmdLet.ParameterSetName -match "Execute") {
												Write-CMLogEntry -Value "Driver files are storage location set to $($OSDDriverPackageLocation)" -Severity 1
											}
											
											switch ($DeploymentType) {
												"BareMetal" {
													# Apply drivers recursively from downloaded driver package location
													Write-CMLogEntry -Value "Driver package content downloaded successfully, attempting to apply drivers using dism.exe located in: $($OSDDriverPackageLocation)" -Severity 1
													
													# Determine driver injection method from parameter input
													switch ($DriverInstallMode) {
														"Single" {
															try {
																# Get driver full path and install each driver seperately
																$DriverINFs = Get-ChildItem -Path $OSDDriverPackageLocation -Recurse -Filter "*.inf" -ErrorAction Stop | Select-Object -Property FullName, Name
																if ($DriverINFs -ne $null) {
																	foreach ($DriverINF in $DriverINFs) {
																		# Install specific driver
																		Write-CMLogEntry -Value "Attempting to install driver: $($DriverINF.FullName)" -Severity 1
																		if ($TSEnvironmentRunning -eq $true) {
																			$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($TSEnvironment.Value('OSDTargetSystemDrive'))\ /Add-Driver /Driver:$($DriverINF.FullName)"
																		}
																		else {
																			$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($DriverINF.FullName)"
																		}
																		
																		# Validate driver injection
																		if ($ApplyDriverInvocation -eq 0) {
																			Write-CMLogEntry -Value "Successfully applied driver using dism.exe" -Severity 1
																		}
																		else {
																			Write-CMLogEntry -Value "An error occurred while applying driver. Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
																		}
																	}
																}
																else {
																	Write-CMLogEntry -Value "An error occurred while enumerating driver paths, downloaded driver package does not contain any INF files" -Severity 3; exit 22
																}
															}
															catch [System.Exception] {
																Write-CMLogEntry -Value "An error occurred while installing drivers. See DISM.log for more details" -Severity 2
															}
														}
														"Recurse" {
															# Apply drivers recursively
															$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($OSDDriverPackageLocation) /Recurse"
															
															# Validate driver injection
															if ($ApplyDriverInvocation -eq 0) {
																Write-CMLogEntry -Value "Successfully applied drivers using dism.exe" -Severity 1
															}
															else {
																Write-CMLogEntry -Value "An error occurred while applying drivers (single package match). Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
															}
														}
													}
												}
												"OSUpgrade" {
													# For OSUpgrade, don't attempt to install drivers as this is handled by setup.exe when used together with OSDUpgradeStagedContent
													Write-CMLogEntry -Value "Driver package content downloaded successfully and located in: $($OSDDriverPackageLocation)" -Severity 1
													
													# Set OSDUpgradeStagedContent task sequence variable
													Write-CMLogEntry -Value "Attempting to set OSDUpgradeStagedContent task sequence variable with value: $($OSDDriverPackageLocation)" -Severity 1
													$TSEnvironment.Value("OSDUpgradeStagedContent") = "$($OSDDriverPackageLocation)"
													Write-CMLogEntry -Value "Successfully completed driver package staging process" -Severity 1
												}
												"DriverUpdate" {
													# Apply drivers recursively from downloaded driver package location
													Write-CMLogEntry -Value "Driver package content downloaded successfully, attempting to apply drivers using pnputil.exe located in: $($OSDDriverPackageLocation)" -Severity 1
													$ApplyDriverInvocation = Invoke-Executable -FilePath "powershell.exe" -Arguments "pnputil /add-driver $(Join-Path -Path $OSDDriverPackageLocation -ChildPath '*.inf') /subdirs /install | Out-File -FilePath (Join-Path -Path $($LogsDirectory) -ChildPath 'Install-Drivers.txt') -Force"
													Write-CMLogEntry -Value "Successfully applied drivers" -Severity 1
												}
											}
										}
										else {
											Write-CMLogEntry -Value "Driver package content download process returned an unhandled exit code: $($DownloadInvocation)" -Severity 3; exit 13
										}
									}
									catch [System.Exception] {
										Write-CMLogEntry -Value "An error occurred while applying drivers (single package match). Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 14
									}
								}
								catch [System.Exception] {
									Write-CMLogEntry -Value "An error occurred while downloading driver package content (single package match). Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 5
								}
							}
							elseif ($PackageList.Count -ge 2) {
								# Handle multiple matches when the computer detection method SystemSKU is used
								if (($ComputerDetectionMethod -like "SystemSKU")) {
									Write-CMLogEntry -Value "Driver package list contains $($PackageList.Count) matches. Attempting to remove driver packages that do not match the computer model." -Severity 1
									
									# Process driver package list in reverse
									for ($i = ($PackageList.Count - 1); $i -ge 0; $i--) {
										switch ($ComputerManufacturer) {
											"Hewlett-Packard" {
												$PackageNameComputerModel = $PackageList[$i].PackageName.Replace("Hewlett-Packard", "HP").Split("-").Trim()[1]
											}
											Default {
												$PackageNameComputerModel = $PackageList[$i].PackageName.Split("-").Replace($ComputerManufacturer, "").Trim()[1]
											}
										}
										if ($PackageNameComputerModel -notmatch $ComputerModel) {
											Write-CMLogEntry -Value "Detected that the following driver package did not match the computer model: $($PackageList[$i].PackageName)"
											Write-CMLogEntry -Value "Removing driver package due to inconsistency between computer model value from WMI '$($ComputerModel)' and the translated driver package computer model name '$($PackageNameComputerModel)'" -Severity 1
											$PackageList.RemoveAt($i)
										}
									}
								}
								
								try {
									Write-CMLogEntry -Value "Driver package list contains multiple matches, attempting to download driver package content based upon latest package creation date" -Severity 1
									
									# Determine matching driver package from array list with vendor specific solutions
									if ($OS -match "Windows 10") {
										Write-CMLogEntry -Value "Attempting to match packages based on Windows 10 version number $($OSVersion)" -Severity 1
										$Package = ($PackageList | Where-Object {
												$_.PackageName -match $OSVersion
											}) | Sort-Object -Property PackageCreated -Descending | Select-Object -First 1
										if ([string]::IsNullOrEmpty($Package)) {
											Write-CMLogEntry -Value "No version specific drivers found. Falling back to match packages based for Windows 10" -Severity 1
											$Package = ($PackageList | Where-Object {
													$_.PackageName -match $OS
											}) | Sort-Object -Property PackageCreated -Descending | Select-Object -First 1
										}
									}
									else {
										$Package = $PackageList | Sort-Object -Property PackageCreated -Descending | Select-Object -First 1
									}
									
									# Validate that there's a package available for download
									if ($Package -ne $null) {
										# Attempt to download driver package content
										Write-CMLogEntry -Value "Attempting to download driver package $($Package.PackageID) content from Distribution Point" -Severity 1
										$DownloadInvocation = Invoke-CMDownloadContent -PackageID $Package.PackageID -DestinationLocationType Custom -DestinationVariableName "OSDDriverPackage" -CustomLocationPath "%_SMSTSMDataPath%\DriverPackage"
										
										try {
											if ($DownloadInvocation -eq 0) {
												$OSDDriverPackageLocation = $($TSEnvironment.Value('OSDDriverPackage01'))
												switch ($DeploymentType) {
													"BareMetal" {
														# Apply drivers recursively from downloaded driver package location
														Write-CMLogEntry -Value "Driver package content downloaded successfully, attempting to apply drivers using dism.exe located in: $($OSDDriverPackageLocation)" -Severity 1
														
														# Determine driver injection method from parameter input
														switch ($DriverInstallMode) {
															"Single" {
																try {
																	# Get driver full path and install each driver seperately
																	$DriverINFs = Get-ChildItem -Path $OSDDriverPackageLocation -Recurse -Filter "*.inf" -ErrorAction Stop | Select-Object -Property FullName, Name
																	if ($DriverINFs -ne $null) {
																		foreach ($DriverINF in $DriverINFs) {
																			# Install specific driver
																			Write-CMLogEntry -Value "Attempting to install driver: $($DriverINF.FullName)" -Severity 1
																			$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($DriverINF.FullName)"																			
																			# Validate driver injection
																			if ($ApplyDriverInvocation -eq 0) {
																				Write-CMLogEntry -Value "Successfully applied driver using dism.exe" -Severity 1
																			}
																			else {
																				Write-CMLogEntry -Value "An error occurred while applying driver. Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
																			}
																		}
																	}
																	else {
																		Write-CMLogEntry -Value "An error occurred while enumerating driver paths, downloaded driver package does not contain any INF files" -Severity 3; exit 22
																	}
																}
																catch [System.Exception] {
																	Write-CMLogEntry -Value "An error occurred while installing drivers. See DISM.log for more details" -Severity 2
																}
															}
															"Recurse" {
																# Apply drivers recursively
																$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($OSDDriverPackageLocation) /Recurse"
																
																# Validate driver injection
																if ($ApplyDriverInvocation -eq 0) {
																	Write-CMLogEntry -Value "Successfully applied drivers using dism.exe" -Severity 1
																}
																else {
																	Write-CMLogEntry -Value "An error occurred while applying drivers (multiple package match). Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
																}
															}
														}
													}
													"OSUpgrade" {
														# For OSUpgrade, don't attempt to install drivers as this is handled by setup.exe when used together with OSDUpgradeStagedContent
														Write-CMLogEntry -Value "Driver package content downloaded successfully and located in: $($OSDDriverPackageLocation)" -Severity 1
														
														# Set OSDUpgradeStagedContent task sequence variable
														Write-CMLogEntry -Value "Attempting to set OSDUpgradeStagedContent task sequence variable with value: $($OSDDriverPackageLocation)" -Severity 1
														$TSEnvironment.Value("OSDUpgradeStagedContent") = "$($OSDDriverPackageLocation)"
														Write-CMLogEntry -Value "Successfully completed driver package staging process" -Severity 1
													}
													"DriverUpdate" {
														# Apply drivers recursively from downloaded driver package location
														Write-CMLogEntry -Value "Driver package content downloaded successfully, attempting to apply drivers using pnputil.exe located in: $($OSDDriverPackageLocation)" -Severity 1
														$ApplyDriverInvocation = Invoke-Executable -FilePath "powershell.exe" -Arguments "pnputil /add-driver $(Join-Path -Path $OSDDriverPackageLocation -ChildPath '*.inf') /subdirs /install | Out-File -FilePath (Join-Path -Path $($LogsDirectory) -ChildPath 'Install-Drivers.txt') -Force"
														Write-CMLogEntry -Value "Successfully applied drivers" -Severity 1
													}
												}
											}
											else {
												Write-CMLogEntry -Value "Driver package content download process returned an unhandled exit code: $($DownloadInvocation)" -Severity 3; exit 13
											}
										}
										catch [System.Exception] {
											Write-CMLogEntry -Value "An error occurred while applying drivers (multiple package match). Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 15
										}
									}
									else {
										Write-CMLogEntry -Value "An error occurred while selecting manufacturer specific driver packages from list, empty list of packages detected" -Severity 3; exit 21
									}
								}
								catch [System.Exception] {
									Write-CMLogEntry -Value "An error occurred while downloading driver package content (multiple package matches). Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 6
								}
							}
							else {
								Write-CMLogEntry -Value "Unable to determine a matching driver package from package list array, unhandled amount of matches" -Severity 2; exit 7
							}
						}
						else {
							Write-CMLogEntry -Value "Script has successfully completed DebugMode" -Severity 1
						}
					}
					else {
						Write-CMLogEntry -Value "Computer model detection logic failed for all detected driver packages" -Severity 2
						Write-CMLogEntry -Value "Reverting to fallback driver package" -Severity 1
					
						$FallBackPath = (Get-ChildItem -Directory -Recurse -Path (Join-Path -Path $StoragePath -ChildPath "Fallback") -Depth 1 | Where-Object {
							($_.FullName -match "$OS") -and ($_.FullName -match $Architecture) -and ($_.FullName -match $OSVersion)
						}).FullName
						
						Write-CMLogEntry -Value "Validating driver package path $($FallBackPath)" -Severity 1
						$Packages = "Fallback"
						
						if (!([string]::IsNullOrEmpty($FallBackPath))) {
							$PackageList.Add($FallBackPath)
							
							# Process package list if not empty
							if ($PSCmdLet.ParameterSetName -notmatch "Debug") {
								if ($PackageList.Count -eq 1) {
									try {
										# Attempt to download driver fallback package content
										Write-CMLogEntry -Value "Attempting to download driver fallback package content" -Severity 1
										# Create temporary driver storage path
										if (!(Test-Path -Path $OSDDriverPackageLocation)) {
											Write-CMLogEntry -Value "Creating local driver storage - $OSDDriverPackageLocation" -Severity 1
											New-Item -Type Dir -Path $OSDDriverPackageLocation | Out-Null
										}
										try {
											Copy-Item -Path $PackageList[0] -Recurse -Destination $OSDDriverPackageLocation -Force
											$DownloadInvocation = 0
										}
										catch [System.Exception] {
											Write-CMLogEntry -Value "An error occurred while copying driver package content. Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 1
										}
										
										try {
											if ($DownloadInvocation -eq 0) {
												switch ($DeploymentType) {
													"BareMetal" {
														# Apply drivers recursively from downloaded driver package location
														Write-CMLogEntry -Value "Fall back driver package content downloaded successfully, attempting to apply drivers using dism.exe located in: $($OSDDriverPackageLocation)" -Severity 1
														# Determine driver injection method from parameter input
														switch ($DriverInstallMode) {
															"Single" {
																try {
																	# Get driver full path and install each driver seperately
																	$DriverINFs = Get-ChildItem -Path $OSDDriverPackageLocation -Recurse -Filter "*.inf" -ErrorAction Stop | Select-Object -Property FullName, Name
																	if ($DriverINFs -ne $null) {
																		foreach ($DriverINF in $DriverINFs) {
																			# Install specific driver
																			Write-CMLogEntry -Value "Attempting to install fall back driver: $($DriverINF.FullName)" -Severity 1
																			$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($DriverINF.FullName)"
																			
																			# Validate driver injection
																			if ($ApplyDriverInvocation -eq 0) {
																				Write-CMLogEntry -Value "Successfully applied fall back driver using dism.exe" -Severity 1
																			}
																			else {
																				Write-CMLogEntry -Value "An error occurred while applying fallback driver. Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
																			}
																		}
																	}
																	else {
																		Write-CMLogEntry -Value "An error occurred while enumerating fallback driver paths, downloaded driver package does not contain any INF files" -Severity 3; exit 22
																	}
																}
																catch [System.Exception] {
																	Write-CMLogEntry -Value "An error occurred while installing fallback drivers. See DISM.log for more details" -Severity 2
																}
															}
															"Recurse" {
																# Apply drivers recursively
																$ApplyDriverInvocation = Invoke-Executable -FilePath "Dism.exe" -Arguments "/Image:$($WindowsImageLocation)\ /Add-Driver /Driver:$($OSDDriverPackageLocation) /Recurse"
																
																
																# Validate driver injection
																if ($ApplyDriverInvocation -eq 0) {
																	Write-CMLogEntry -Value "Successfully applied fall back drivers using dism.exe" -Severity 1
																}
																else {
																	Write-CMLogEntry -Value "An error occurred while applying fallback drivers. Continuing with warning code: $($ApplyDriverInvocation). See DISM.log for more details" -Severity 2
																}
															}
														}
													}
													"OSUpgrade" {
														# Not a supported scenario as of yet
														Write-CMLogEntry -Value "Fall back driver package mode is not supported for OSUpgrades, bailing out" -Severity 2
													}
													"DriverUpdate" {
														# Apply drivers recursively from downloaded driver package location
														Write-CMLogEntry -Value "Driver fallback package content downloaded successfully, attempting to apply drivers using pnputil.exe located in: $($OSDDriverPackageLocation)" -Severity 1
														$ApplyDriverInvocation = Invoke-Executable -FilePath "powershell.exe" -Arguments "pnputil /add-driver $(Join-Path -Path $OSDDriverPackageLocation -ChildPath '*.inf') /subdirs /install | Out-File -FilePath (Join-Path -Path $($LogsDirectory) -ChildPath 'Install-Drivers.txt') -Force"
													}
												}
											}
											else {
												Write-CMLogEntry -Value "Fallback driver package content download process returned an unhandled exit code: $($DownloadInvocation)" -Severity 3; exit 20
											}
										}
										catch [System.Exception] {
											Write-CMLogEntry -Value "An error occurred while applying fallback drivers. Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 18
										}
									}
									catch [System.Exception] {
										Write-CMLogEntry -Value "An error occurred while downloading fallback driver package content. Error message at line $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.Message)" -Severity 3; exit 17
									}
								}
								else {
									Write-CMLogEntry -Value "Either empty or an unsupported count of fallback package content detected" -Severity 3; exit 16
								}
							}
							else {
								Write-CMLogEntry -Value "Script has successfully completed debug mode" -Severity 1
							}
						}
						else {
							Write-CMLogEntry -Value "Empty driver package list detected, unable to determine matching driver fallback package" -Severity 2; exit 8
						}
					}
				}
				else {
					Write-CMLogEntry -Value "Computer model and SystemSKU values are either null or empty strings" -Severity 2
				}
			}
			else {
				Write-CMLogEntry -Value "No packages found. Please populate the driver repository" -Severity 2; exit 10
			}
		}
		else {
			Write-CMLogEntry -Value "Unsupported computer platform detected, virtual machines are not supported" -Severity 2
		}
	}
	else {
		Write-CMLogEntry -Value "Unable to detect current operating system name from task sequence reference objects" -Severity 2; exit 11
	}
}
End {
	if (($CleanUp -eq $true) -and (!([string]::IsNullOrEmpty($OSDDriverPackageLocation)))) {
		# Remove driver packages on local machine
		if (Test-Path -Path $OSDDriverPackageLocation) {
			try {
				Write-CMLogEntry -Value "Removing driver download folder from local system" -Severity 1
				Remove-Item -Path $OSDDriverPackageLocation -Recurse -Force
			}
			catch [System.Exception] {
				Write-CMLogEntry -Value "Errors occured while trying to remove driver download folder: $($_.Exception.Message)" -Severity 2
			}
		}
	}
}
